{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to My Wordle Bot Project!","text":"<p>This has been a long project in the making!</p> <p>Wordle Bot is available as a package and runs every day in a GitHub runner.</p>"},{"location":"docs/","title":"Documentation","text":"<p>Main function that handles creating an instance and solving wordle.</p> <p>Wordle Module, connects to and plays Wordle</p>"},{"location":"docs/#wordle_bot.__main__.solve","title":"<code>solve(first_guess='')</code>","text":"<p>Solve the wordle by selecting random 'best guesses'.</p> <pre><code>Args:\n    first_guess (str, optional):\n        The first guess the wordle solver will use.\n        If blank, will just pick a random word. Defaults to \"\".\n\nRaises:\n    ValueError:\n        Will raise a ValueError if provided an invalid first guess.\n</code></pre> Source code in <code>src/wordle_bot/__main__.py</code> <pre><code>def solve(first_guess: str = \"\") -&gt; None:\n    \"\"\"\n    Solve the wordle by selecting random 'best guesses'.\n\n        Args:\n            first_guess (str, optional):\n                The first guess the wordle solver will use.\n                If blank, will just pick a random word. Defaults to \"\".\n\n        Raises:\n            ValueError:\n                Will raise a ValueError if provided an invalid first guess.\n\n    \"\"\"\n    # Solve wordle\n    for _ in range(5):  # Attempts to solve wordle 5 times in case it fails\n        wordle = Wordle(headless=True)\n        solved = wordle.solve(first_guess=first_guess)\n        if solved is True:\n            break\n\n    if os.getenv(\"GITHUB_WORKSPACE\"):\n        output_file(wordle)\n</code></pre>"},{"location":"docs/#wordle_bot.wordle.Wordle","title":"<code>Wordle</code>","text":"<p>Handles all the logic for connecting to NYT website and playing Wordle.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Will raise a value error if you provide an invalid first guess when using Wordle.solve().</p> <p>Parameters:</p> Name Type Description Default <code>headless</code> <code>bool</code> <p>Will run the selenium browser in headless mode. You will still be able to see what is going on since it will build a dynamic table in the console. Defaults to False.</p> <code>False</code> Source code in <code>src/wordle_bot/wordle.py</code> <pre><code>class Wordle:\n    \"\"\"\n    Handles all the logic for connecting to NYT website and playing Wordle.\n\n    Raises:\n        ValueError:\n            Will raise a value error if you provide an\n            invalid first guess when using Wordle.solve().\n\n    Args:\n        headless (bool, optional):\n            Will run the selenium browser in headless mode.\n            You will still be able to see what is going on since\n            it will build a dynamic table in the console.\n            Defaults to False.\n    \"\"\"\n\n    NYT_WEBSITE = \"https://www.nytimes.com/games/wordle/index.html\"\n    PLAY_BUTTON_CLASS = \"Welcome-module_button__ZG0Zh\"\n    CLOSE_POPUP_CLASS = \"Modal-module_closeIconButton__y9b6c\"\n    ROW_CLASS = \"Row-module_row__pwpBq\"\n    TILE_CLASS = \"Tile-module_tile__UWEHN\"\n    CSS_EMPTY = \".Tile-module_tile__UWEHN[data-state=empty]\"\n    CSS_ABSENT = \".Tile-module_tile__UWEHN[data-state=absent]\"\n    CSS_CORRECT = \".Tile-module_tile__UWEHN[data-state=correct]\"\n    CSS_PRESENT = \".Tile-module_tile__UWEHN[data-state=present]\"\n    FIVE_LETTER_WORDS_ABSOLUTE_PATH = os.path.join(os.path.dirname(os.path.realpath(__file__)),\n        \"five_letter_words.json\",\n    )\n\n    def __init__(self, headless: bool = False) -&gt; None:\n        self.console = Console()\n        with self.console.status(\"Setting up Wordle...\"):\n            try:\n                response = requests.get(\"https://raw.githubusercontent.com/Jampamane/wordle_bot/refs/heads/main/five_letter_words.json\")\n                response.raise_for_status()\n                self.five_letter_words = response.json()\n            except requests.RequestException as e:\n                print(\"Error fetching data:\", e)\n            except ValueError as e:\n                print(\"Error decoding JSON:\", e)\n\n            self.potential_words = self.five_letter_words\n            self.potential_letters = [\n                \"a\",\n                \"b\",\n                \"c\",\n                \"d\",\n                \"e\",\n                \"f\",\n                \"g\",\n                \"h\",\n                \"i\",\n                \"j\",\n                \"k\",\n                \"l\",\n                \"m\",\n                \"n\",\n                \"o\",\n                \"p\",\n                \"q\",\n                \"r\",\n                \"s\",\n                \"t\",\n                \"u\",\n                \"v\",\n                \"w\",\n                \"x\",\n                \"y\",\n                \"z\",\n            ]\n            self.style_dict = {\n                \"absent\": \"grey53\",\n                \"present\": \"yellow bold\",\n                \"correct\": \"green bold\",\n                \"tbd\": \"red\",\n            }\n            self.wordle = {\n                \"letters\": {\n                    1: {\"correct\": \"\", \"incorrect\": []},\n                    2: {\"correct\": \"\", \"incorrect\": []},\n                    3: {\"correct\": \"\", \"incorrect\": []},\n                    4: {\"correct\": \"\", \"incorrect\": []},\n                    5: {\"correct\": \"\", \"incorrect\": []},\n                },\n                \"absent_letters\": [],\n                \"present_letters\": [],\n                \"guess\": {\n                    1: {\"word\": \"\", \"letters\": []},\n                    2: {\"word\": \"\", \"letters\": []},\n                    3: {\"word\": \"\", \"letters\": []},\n                    4: {\"word\": \"\", \"letters\": []},\n                    5: {\"word\": \"\", \"letters\": []},\n                    6: {\"word\": \"\", \"letters\": []},\n                },\n            }\n            options = Options()\n            options.add_experimental_option(\"excludeSwitches\", [\"enable-logging\"])\n            options.add_argument(\"--log-level=3\")\n            options.add_argument(\"--no-sandbox\")  # Bypass OS security model\n            options.add_argument(\"--disable-dev-shm-usage\")  # Overcome limited resource issues\n            options.add_argument(\"--disable-gpu\")  # Applicable for Windows/Linux GUI environments\n            options.add_argument(\"--remote-debugging-port=9222\")  # Debugging port for ChromeDriver\n            options.add_argument(\"--disable-software-rasterizer\")  # Avoid GPU rendering issues\n            options.add_argument(\"--disable-extensions\")\n            options.add_argument(\"--disable-logging\")\n            options.add_argument(\"--disable-popup-blocking\")\n            if headless is True:\n                options.add_argument(\"--headless\")\n            options.add_argument(\"--ignore-certificate-errors\")\n            options.add_argument(\"--ignore-ssl-errors\")\n\n            try:\n                self.browser = Chrome(options=options)\n            except SessionNotCreatedException as e:\n                self.console.print(\"Selenium web browser failed to start!\", style=\"red\")\n                self.console.print(\"You might be missing some dependencies.\", style=\"red\")\n                self.console.print(\"Selenium error: SessionNotCreatedException\", style=\"yellow\")\n                exit(3)\n\n            self.action_chains = ActionChains(self.browser)\n\n            self.browser.get(self.NYT_WEBSITE)\n\n            # ----------------------------------------------------------------------------------\n            # NEW YORK TIMES \"WE'VE UPDATED OUR TERMS OF SERVICE\" BUTTON\n            try:\n                WebDriverWait(self.browser, 10).until(\n                    EC.presence_of_element_located(\n                        (By.CLASS_NAME, \"purr-blocker-card__button\")\n                    )\n                )\n                self.browser.find_element(\n                    By.CLASS_NAME, \"purr-blocker-card__button\"\n                ).click()\n            except TimeoutException:\n                pass\n            # -----------------------------------------------------------------------------------\n\n            WebDriverWait(self.browser, 10).until(\n                EC.presence_of_element_located((By.CLASS_NAME, self.PLAY_BUTTON_CLASS))\n            )\n            play = self.browser.find_elements(By.CLASS_NAME, self.PLAY_BUTTON_CLASS)[-1]\n            play.click()\n            time.sleep(1)\n            self.action_chains.send_keys(Keys.ESCAPE).perform()\n            time.sleep(1)\n\n            last_row = self.browser.find_elements(By.CLASS_NAME, self.ROW_CLASS)[5]\n            self.action_chains.scroll_to_element(last_row).perform()\n\n    @property\n    def wordle_today(self) -&gt; str:\n        \"\"\"\n        Grabs today's wordle from the Wordle Class's wordle dictionary.\n        Only works if wordle has been solved.\n\n        Returns:\n            str: Today's wordle.\n        \"\"\"\n        return str(\n            self.wordle[\"letters\"][1][\"correct\"]\n            + self.wordle[\"letters\"][2][\"correct\"]\n            + self.wordle[\"letters\"][3][\"correct\"]\n            + self.wordle[\"letters\"][4][\"correct\"]\n            + self.wordle[\"letters\"][5][\"correct\"]\n        )\n\n    def build_layout(self, guess=\"\", style=\"yellow\") -&gt; Layout:\n        \"\"\"\n        Dynamically build the layout in the console so\n        the user can see how the wordle is being solved.\n\n        Args:\n            guess (str, optional):\n                The 5 letter word that is being guessed. Defaults to \"\".\n            style (str, optional):\n                The color that the guess will be displayed as. Defaults to \"yellow\".\n\n        Returns:\n            Layout: Layout object for displaying wordle.\n        \"\"\"\n\n        print_guess = False\n        table = Table(title=\"Wordle\", show_header=False)\n        table.add_column(\"Guess\", width=5, justify=\"center\")\n        table.add_column(\"1\", width=1, justify=\"center\")\n        table.add_column(\"2\", width=1, justify=\"center\")\n        table.add_column(\"3\", width=1, justify=\"center\")\n        table.add_column(\"4\", width=1, justify=\"center\")\n        table.add_column(\"5\", width=1, justify=\"center\")\n        for x in range(1, 7):\n            if self.wordle[\"guess\"][x][\"letters\"]:\n                table.add_row(\n                    self.wordle[\"guess\"][x][\"word\"].capitalize(),\n                    f\"[{self.wordle['guess'][x]['letters'][0][1]}]{self.wordle['guess'][x]['letters'][0][0]}\",\n                    f\"[{self.wordle['guess'][x]['letters'][1][1]}]{self.wordle['guess'][x]['letters'][1][0]}\",\n                    f\"[{self.wordle['guess'][x]['letters'][2][1]}]{self.wordle['guess'][x]['letters'][2][0]}\",\n                    f\"[{self.wordle['guess'][x]['letters'][3][1]}]{self.wordle['guess'][x]['letters'][3][0]}\",\n                    f\"[{self.wordle['guess'][x]['letters'][4][1]}]{self.wordle['guess'][x]['letters'][4][0]}\",\n                )\n                table.add_section()\n            elif not guess:\n                table.add_row(str(x), style=\"cyan\")\n                table.add_section()\n            elif print_guess is False:\n                print_guess = True\n                table.add_row(guess.capitalize(), style=style)\n                table.add_section()\n            else:\n                table.add_row(str(x), style=\"cyan\")\n                table.add_section()\n\n        letters = Table(show_header=False, show_lines=False, show_edge=False)\n        letters.add_row(\n            f\"Total potential words: [cyan bold]{len(self.potential_words.keys())}\"\n        )\n        words = Table(show_header=False, show_lines=False, show_edge=False)\n        words.add_row(str(self.potential_letters))\n        words.add_section()\n        words.add_row(str(list(self.potential_words.keys())))\n\n        layout = Layout()\n        layout.split_row(Layout(name=\"table\"), Layout(name=\"info\"))\n        layout[\"info\"].split_column(Layout(name=\"letters\"), Layout(name=\"words\"))\n        layout[\"table\"].size = 33\n        layout[\"letters\"].size = 3\n        layout[\"table\"].update(Panel(table))\n        layout[\"letters\"].update(Panel(letters))\n        layout[\"words\"].update(Panel(words))\n        return layout\n\n    def _submit_guess(self, guess: str, row_number: int) -&gt; bool:\n        \"\"\"Submits the guess to NYT Wordle.\n\n        Args:\n            guess (str):\n                Guess to submit.\n            row_number (int):\n                Row number the guess is being submitted to.\n                Used for validating if the guess was successful or not.\n\n        Returns:\n            bool: True or False based on if guess was successfully submitted.\n        \"\"\"\n        for letter in guess:\n            self.action_chains.send_keys(letter).perform()\n            time.sleep(0.1)\n        self.action_chains.send_keys(Keys.ENTER).perform()\n        time.sleep(2.5)\n\n        row = self.browser.find_elements(By.CLASS_NAME, self.ROW_CLASS)[row_number - 1]\n        tiles = row.find_elements(By.CLASS_NAME, self.TILE_CLASS)\n        for letter in tiles:\n            letter_check = letter.get_attribute(\"data-state\")\n            if letter_check == \"tbd\":\n                return False\n        return True\n\n    def _is_letter_duplicate(self, letter: str, word: str) -&gt; bool:\n        \"\"\"Checks if a given letter shows up more than once in a word.\n\n        Args:\n            letter (str): Letter to check for duplicate.\n            word (str): Word to check letter duplicate.\n\n        Returns:\n            bool: True if duplicate, False if otherwise.\n        \"\"\"\n        count = 0\n        for word_letter in word:\n            if word_letter == letter:\n                count += 1\n        if count &gt; 1:\n            return True\n        return False\n\n    def _totally_absent(self, row_number: int, letter: str) -&gt; bool:\n        row = self.browser.find_elements(By.CLASS_NAME, self.ROW_CLASS)[row_number - 1]\n        tiles = row.find_elements(By.CLASS_NAME, self.TILE_CLASS)\n        for tile_letter in tiles:\n            if tile_letter.text.lower() == letter:\n                if tile_letter.get_attribute(\"data-state\") != \"absent\":\n                    return False\n        return True\n\n    def _update_wordle(self, row_number: int, word: str) -&gt; None:\n        self.wordle[\"guess\"][row_number][\"word\"] = word\n        row = self.browser.find_elements(By.CLASS_NAME, self.ROW_CLASS)[row_number - 1]\n        tiles = row.find_elements(By.CLASS_NAME, self.TILE_CLASS)\n        for indx, letter in enumerate(tiles, start=1):\n            letter_check = letter.get_attribute(\"data-state\")\n            if letter_check == \"absent\":\n                if (\n                    self._is_letter_duplicate(letter=letter.text.lower(), word=word)\n                    is True\n                ):\n                    if (\n                        self._totally_absent(\n                            row_number=row_number, letter=letter.text.lower()\n                        )\n                        is False\n                    ):\n                        self.wordle[\"letters\"][indx][\"incorrect\"].append(\n                            letter.text.lower()\n                        )\n                    else:\n                        self.wordle[\"absent_letters\"].append(letter.text.lower())\n                else:\n                    self.wordle[\"absent_letters\"].append(letter.text.lower())\n            elif letter_check == \"correct\":\n                self.wordle[\"letters\"][indx][\"correct\"] = letter.text.lower()\n                self.wordle[\"present_letters\"].append(letter.text.lower())\n            elif letter_check == \"present\":\n                self.wordle[\"present_letters\"].append(letter.text.lower())\n                self.wordle[\"letters\"][indx][\"incorrect\"].append(letter.text.lower())\n\n            self.wordle[\"guess\"][row_number][\"letters\"].append(\n                (letter.text, self.style_dict[letter_check])\n            )\n\n    def _check_for_present_letters(self, word):\n        if self.wordle[\"present_letters\"]:\n            for present_letter in self.wordle[\"present_letters\"]:\n                if present_letter not in word:\n                    return False\n        return True\n\n    def _get_potential_words(self):\n        potential_words = {}\n        for word in self.potential_words.keys():\n            if self._check_for_present_letters(word) is False:\n                continue\n\n            for indx, letter in enumerate(word, start=1):\n                if letter in self.wordle[\"absent_letters\"]:\n                    break\n                if letter in self.wordle[\"letters\"][indx][\"incorrect\"]:\n                    break\n\n                if not self.wordle[\"letters\"][indx][\"correct\"]:\n                    pass\n                elif letter != self.wordle[\"letters\"][indx][\"correct\"]:\n                    break\n\n                if indx == 5:\n                    potential_words[word] = 1\n        return potential_words\n\n    def _check_for_win(self, check_word: str):\n        for indx in range(1, 6):\n            if not self.wordle[\"letters\"][indx][\"correct\"]:\n                return False\n        if check_word != self.wordle_today:\n            return False\n        return True\n\n    def _delete_guess(self, guess: str):\n        for _ in range(5):\n            self.action_chains.send_keys(Keys.BACK_SPACE).perform()\n            time.sleep(0.1)\n        try:\n            self.potential_words.pop(guess)\n        except KeyError:\n            pass\n\n        try:\n            self.five_letter_words.pop(guess)\n        except KeyError:\n            pass\n\n        with open(self.FIVE_LETTER_WORDS_ABSOLUTE_PATH, \"w\", encoding=\"utf-8\") as file:\n            file.write(json.dumps(self.five_letter_words, indent=1))\n\n    def _get_available_letters(self) -&gt; dict:\n        availible_letters = {}\n        for word in self.potential_words.keys():\n            for letter in word:\n                availible_letters[letter] = 1\n\n        for indx in range(1, 6):\n            try:\n                availible_letters.pop(self.wordle[\"letters\"][indx][\"correct\"])\n            except KeyError:\n                pass\n        self.potential_letters = list(availible_letters.keys())\n        return availible_letters\n\n    def _get_best_guess(self, score: int = 5) -&gt; str:\n        \"\"\"\n        Generates a list of best guesses based on the remaining\n        letters from the list of potential remaining words.\n\n        Args:\n            score (int, optional):\n                Defaults to 5. Used in recusion. If function can't find a word that\n                includes 5 unique letters from the list of potential letters\n                then it will call the function again with a score of -= 1.\n\n        Returns:\n            guess (str):\n                Random guess for the list of potential guesses.\n        \"\"\"\n        best_guesses = []\n        availible_letters = self._get_available_letters()\n\n        if len(self.potential_words) == 1 or len(availible_letters) == 0:\n            best_guess = list(self.potential_words.keys())[0]\n            return best_guess\n\n        if len(self.potential_words) == 2:\n            best_guess = random.choice(list(self.potential_words.keys()))\n            return best_guess\n\n        for word in self.five_letter_words:\n            for index, letter in enumerate(word, start=1):\n                if self._is_letter_duplicate(letter=letter, word=word) is True:\n                    break\n                if letter in self.wordle[\"letters\"][index][\"incorrect\"]:\n                    break\n\n                if index == 5:\n                    word_score = 0\n                    for availible_letter in availible_letters:\n                        if availible_letter in word:\n                            word_score += 1\n                    if word_score == score:\n                        best_guesses.append(word)\n        if len(best_guesses) == 0:\n            guess = self._get_best_guess(score=score - 1)\n        else:\n            guess = random.choice(best_guesses)\n        return guess\n\n    def _close_popups(self) -&gt; None:\n        \"\"\"Closes the popups when done solving the Wordle.\"\"\"\n        WebDriverWait(self.browser, 5).until(\n            EC.presence_of_element_located((By.CLASS_NAME, self.CLOSE_POPUP_CLASS))\n        ).click()\n        time.sleep(0.5)\n        WebDriverWait(self.browser, 5).until(\n            EC.presence_of_element_located((By.CLASS_NAME, self.CLOSE_POPUP_CLASS))\n        ).click()\n\n    def solve(self, first_guess: str = \"\") -&gt; bool:\n        \"\"\"Solve the wordle by selecting random 'best guesses'.\n\n        Args:\n            first_guess (str, optional):\n                The first guess the wordle solver will use.\n                If blank, will just pick a random word. Defaults to \"\".\n\n        Raises:\n            ValueError:\n                Will raise a ValueError if provided an invalid first guess.\n\n        Returns:\n            bool: True if successfully solved, False if otherwise.\n        \"\"\"\n        with Live(self.build_layout()) as live:\n            if first_guess:\n                live.update(self.build_layout(guess=first_guess))\n            if not first_guess:\n                first_guess = random.choice(list(self.potential_words.keys()))\n                live.update(self.build_layout(guess=first_guess))\n                while self._submit_guess(guess=first_guess, row_number=1) is False:\n                    live.update(self.build_layout(guess=first_guess, style=\"red bold\"))\n                    self._delete_guess(first_guess)\n                    first_guess = random.choice(list(self.potential_words.keys()))\n                    live.update(self.build_layout(guess=first_guess))\n            elif self._submit_guess(guess=first_guess, row_number=1) is False:\n                raise ValueError(\"You have provided an invalid first guess.\")\n            self._update_wordle(row_number=1, word=first_guess)\n            live.update(self.build_layout())\n            if self._check_for_win(first_guess) is True:\n                self._close_popups()\n                return True\n\n            for indx in range(2, 7):\n                self.potential_words = self._get_potential_words()\n                new_guess = self._get_best_guess()\n                live.update(self.build_layout(guess=new_guess))\n                while self._submit_guess(guess=new_guess, row_number=indx) is False:\n                    live.update(self.build_layout(guess=new_guess, style=\"red bold\"))\n                    self._delete_guess(new_guess)\n                    new_guess = self._get_best_guess()\n                    live.update(self.build_layout(guess=new_guess))\n                self._update_wordle(row_number=indx, word=new_guess)\n                live.update(self.build_layout())\n                if self._check_for_win(new_guess) is True:\n                    break\n\n        self._close_popups()\n        if self._check_for_win(new_guess) is True:\n            self.console.print(\n                f\"Today's wordle is: [green bold]{self.wordle_today.upper()}\",\n                justify=\"center\",\n            )\n            return True\n        self.console.print(\n            \"Looks like the bot failed wordle today...\", justify=\"center\"\n        )\n        return False\n</code></pre>"},{"location":"docs/#wordle_bot.wordle.Wordle.wordle_today","title":"<code>wordle_today</code>  <code>property</code>","text":"<p>Grabs today's wordle from the Wordle Class's wordle dictionary. Only works if wordle has been solved.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Today's wordle.</p>"},{"location":"docs/#wordle_bot.wordle.Wordle.build_layout","title":"<code>build_layout(guess='', style='yellow')</code>","text":"<p>Dynamically build the layout in the console so the user can see how the wordle is being solved.</p> <p>Parameters:</p> Name Type Description Default <code>guess</code> <code>str</code> <p>The 5 letter word that is being guessed. Defaults to \"\".</p> <code>''</code> <code>style</code> <code>str</code> <p>The color that the guess will be displayed as. Defaults to \"yellow\".</p> <code>'yellow'</code> <p>Returns:</p> Name Type Description <code>Layout</code> <code>Layout</code> <p>Layout object for displaying wordle.</p> Source code in <code>src/wordle_bot/wordle.py</code> <pre><code>def build_layout(self, guess=\"\", style=\"yellow\") -&gt; Layout:\n    \"\"\"\n    Dynamically build the layout in the console so\n    the user can see how the wordle is being solved.\n\n    Args:\n        guess (str, optional):\n            The 5 letter word that is being guessed. Defaults to \"\".\n        style (str, optional):\n            The color that the guess will be displayed as. Defaults to \"yellow\".\n\n    Returns:\n        Layout: Layout object for displaying wordle.\n    \"\"\"\n\n    print_guess = False\n    table = Table(title=\"Wordle\", show_header=False)\n    table.add_column(\"Guess\", width=5, justify=\"center\")\n    table.add_column(\"1\", width=1, justify=\"center\")\n    table.add_column(\"2\", width=1, justify=\"center\")\n    table.add_column(\"3\", width=1, justify=\"center\")\n    table.add_column(\"4\", width=1, justify=\"center\")\n    table.add_column(\"5\", width=1, justify=\"center\")\n    for x in range(1, 7):\n        if self.wordle[\"guess\"][x][\"letters\"]:\n            table.add_row(\n                self.wordle[\"guess\"][x][\"word\"].capitalize(),\n                f\"[{self.wordle['guess'][x]['letters'][0][1]}]{self.wordle['guess'][x]['letters'][0][0]}\",\n                f\"[{self.wordle['guess'][x]['letters'][1][1]}]{self.wordle['guess'][x]['letters'][1][0]}\",\n                f\"[{self.wordle['guess'][x]['letters'][2][1]}]{self.wordle['guess'][x]['letters'][2][0]}\",\n                f\"[{self.wordle['guess'][x]['letters'][3][1]}]{self.wordle['guess'][x]['letters'][3][0]}\",\n                f\"[{self.wordle['guess'][x]['letters'][4][1]}]{self.wordle['guess'][x]['letters'][4][0]}\",\n            )\n            table.add_section()\n        elif not guess:\n            table.add_row(str(x), style=\"cyan\")\n            table.add_section()\n        elif print_guess is False:\n            print_guess = True\n            table.add_row(guess.capitalize(), style=style)\n            table.add_section()\n        else:\n            table.add_row(str(x), style=\"cyan\")\n            table.add_section()\n\n    letters = Table(show_header=False, show_lines=False, show_edge=False)\n    letters.add_row(\n        f\"Total potential words: [cyan bold]{len(self.potential_words.keys())}\"\n    )\n    words = Table(show_header=False, show_lines=False, show_edge=False)\n    words.add_row(str(self.potential_letters))\n    words.add_section()\n    words.add_row(str(list(self.potential_words.keys())))\n\n    layout = Layout()\n    layout.split_row(Layout(name=\"table\"), Layout(name=\"info\"))\n    layout[\"info\"].split_column(Layout(name=\"letters\"), Layout(name=\"words\"))\n    layout[\"table\"].size = 33\n    layout[\"letters\"].size = 3\n    layout[\"table\"].update(Panel(table))\n    layout[\"letters\"].update(Panel(letters))\n    layout[\"words\"].update(Panel(words))\n    return layout\n</code></pre>"},{"location":"docs/#wordle_bot.wordle.Wordle.solve","title":"<code>solve(first_guess='')</code>","text":"<p>Solve the wordle by selecting random 'best guesses'.</p> <p>Parameters:</p> Name Type Description Default <code>first_guess</code> <code>str</code> <p>The first guess the wordle solver will use. If blank, will just pick a random word. Defaults to \"\".</p> <code>''</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Will raise a ValueError if provided an invalid first guess.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if successfully solved, False if otherwise.</p> Source code in <code>src/wordle_bot/wordle.py</code> <pre><code>def solve(self, first_guess: str = \"\") -&gt; bool:\n    \"\"\"Solve the wordle by selecting random 'best guesses'.\n\n    Args:\n        first_guess (str, optional):\n            The first guess the wordle solver will use.\n            If blank, will just pick a random word. Defaults to \"\".\n\n    Raises:\n        ValueError:\n            Will raise a ValueError if provided an invalid first guess.\n\n    Returns:\n        bool: True if successfully solved, False if otherwise.\n    \"\"\"\n    with Live(self.build_layout()) as live:\n        if first_guess:\n            live.update(self.build_layout(guess=first_guess))\n        if not first_guess:\n            first_guess = random.choice(list(self.potential_words.keys()))\n            live.update(self.build_layout(guess=first_guess))\n            while self._submit_guess(guess=first_guess, row_number=1) is False:\n                live.update(self.build_layout(guess=first_guess, style=\"red bold\"))\n                self._delete_guess(first_guess)\n                first_guess = random.choice(list(self.potential_words.keys()))\n                live.update(self.build_layout(guess=first_guess))\n        elif self._submit_guess(guess=first_guess, row_number=1) is False:\n            raise ValueError(\"You have provided an invalid first guess.\")\n        self._update_wordle(row_number=1, word=first_guess)\n        live.update(self.build_layout())\n        if self._check_for_win(first_guess) is True:\n            self._close_popups()\n            return True\n\n        for indx in range(2, 7):\n            self.potential_words = self._get_potential_words()\n            new_guess = self._get_best_guess()\n            live.update(self.build_layout(guess=new_guess))\n            while self._submit_guess(guess=new_guess, row_number=indx) is False:\n                live.update(self.build_layout(guess=new_guess, style=\"red bold\"))\n                self._delete_guess(new_guess)\n                new_guess = self._get_best_guess()\n                live.update(self.build_layout(guess=new_guess))\n            self._update_wordle(row_number=indx, word=new_guess)\n            live.update(self.build_layout())\n            if self._check_for_win(new_guess) is True:\n                break\n\n    self._close_popups()\n    if self._check_for_win(new_guess) is True:\n        self.console.print(\n            f\"Today's wordle is: [green bold]{self.wordle_today.upper()}\",\n            justify=\"center\",\n        )\n        return True\n    self.console.print(\n        \"Looks like the bot failed wordle today...\", justify=\"center\"\n    )\n    return False\n</code></pre>"},{"location":"final_table/","title":"Today's Wordle","text":"<p>This page displays the results from a GitHub runner, which runs the wordle-bot every single day.</p> <p>If everything is working correctly, then below should be what the wordle is today:</p> Smarm S M A R M Cunei C U N E I Dowly D O W L Y Farts F A R T S Defer D E F E R The Wordle for 2025-09-20 is: DEFER"}]}